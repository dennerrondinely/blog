---
title: 'Context API vs Zustand: Qual escolher para gerenciar estado no React?'
description: 'ComparaÃ§Ã£o prÃ¡tica entre React Context (Broadcast) e Zustand (Subscription). Entenda as diferenÃ§as, casos de uso e quando usar cada uma.'
date: '2026-02-14'
tags: ['react', 'typescript', 'state-management', 'zustand', 'best-practices']
locale: 'pt'
---

# ğŸ”„ Context API vs Zustand: Qual escolher para gerenciar estado no React?

Quando vocÃª comeÃ§a a trabalhar com React, cedo ou tarde enfrenta a pergunta: **como devo gerenciar o estado da minha aplicaÃ§Ã£o?**

A resposta mais comum Ã© "use Context API" - afinal, vem com React. Mas serÃ¡ que Ã© sempre a melhor escolha? Vamos comparar Context com Zustand de forma prÃ¡tica e didÃ¡tica.

---

## ğŸ“Š Context API: Broadcast (TransmissÃ£o)

Context funciona em um modelo de **broadcast**, onde:

1. VocÃª cria um context com um valor
2. Quando esse valor muda, **todo componente que se inscreve Ã© notificado**
3. **Todos os inscritos re-renderizam**, mesmo que nÃ£o usem a parte que mudou

### Exemplo com Context

```typescript
// context-broadcast-example.tsx
const AppContext = createContext({
  user: { name: "John" },
  theme: "light",
});

function UserProfile() {
  const { user } = useContext(AppContext);
  return <span>{user.name}</span>;
}

function ThemeToggle() {
  const { theme } = useContext(AppContext);
  return <button>{theme}</button>;
}

// Se "theme" changes, UserProfile re-renders too.
// UserProfile does NOT re-render.
```

**O problema:** Se o `theme` muda, `UserProfile` tambÃ©m re-renderiza, mesmo que ele sÃ³ use `user`. Isso pode causar performance issues em apps grandes.

---

## ğŸ“¡ Zustand: Subscription (InscriÃ§Ã£o)

Zustand funciona com um modelo de **subscription**, onde:

1. Cada componente se inscreve **especificamente** na parte do estado que precisa
2. Quando essa parte muda, **apenas os componentes inscritos nela re-renderizam**
3. Componentes que usam outras partes nÃ£o sÃ£o afetados

### Exemplo com Zustand

```typescript
// zustand-subscription-example.tsx
const useAppStore = create(set => ({
  user: { name: "John" },
  theme: "light"
}));

function UserProfile() {
  const user = useAppStore(state => state.user);
  return <span>{user.name}</span>;
}

function ThemeToggle() {
  const theme = useAppStore(state => state.theme);
  return <button>{theme}</button>;
}

// If "theme" changes, UserProfile does NOT re-render.
```

**O benefÃ­cio:** Apenas `ThemeToggle` re-renderiza quando o tema muda. `UserProfile` fica intacto.

---

## ğŸ¯ ComparaÃ§Ã£o Lado a Lado

| Aspecto                  | Context                               | Zustand                                    |
| ------------------------ | ------------------------------------- | ------------------------------------------ |
| **Re-renders**           | Broadcast (todos que usam context)    | Subscription (apenas inscritos na mudanÃ§a) |
| **Performance**          | Pode causar re-renders desnecessÃ¡rios | Otimizado, re-renders seletivos            |
| **Setup**                | Simples, vem com React                | Requer instalaÃ§Ã£o (`npm install zustand`)  |
| **Boilerplate**          | Context + Provider + Hook             | Apenas um hook                             |
| **Flexibilidade**        | Limitado para estado complexo         | Excelente para estado complexo             |
| **DevTools**             | NÃ£o vem com ferramentas               | Suporta Redux DevTools                     |
| **Curva de aprendizado** | Muito simples                         | Simples, um pouco maior que Context        |

---

## ğŸš¨ Quando Use Context

Context Ã© perfeito para:

âœ… **Estado simples e global** - Tema (light/dark), idioma  
âœ… **Apps pequenos** - Poucos componentes, sem re-renders frequentes  
âœ… **VocÃª quer zero dependÃªncias** - NÃ£o quer adicionar bibliotecas  
âœ… **AutenticaÃ§Ã£o simples** - User logged in / logged out  
âœ… **Valores que mudam raramente** - ConfiguraÃ§Ãµes da app

```typescript
// Bom uso de Context
const AuthContext = createContext();

// Renderiza muitas vezes? NÃ£o Ã© um problema se mudar raramente
const user = useContext(AuthContext);
```

---

## âš¡ Quando Use Zustand

Zustand Ã© melhor para:

âœ… **Estado complexo** - MÃºltiplas aÃ§Ãµes, lÃ³gica intrincada  
âœ… **Muitas mudanÃ§as de estado** - Updates frequentes  
âœ… **Apps mÃ©dias/grandes** - Performance Ã© crÃ­tica  
âœ… **Estado compartilhado entre muitos componentes** - Evita re-renders em cascata  
âœ… **VocÃª quer DevTools** - Debug com Redux DevTools  
âœ… **Middleware** - Logging, persistÃªncia, etc.

```typescript
// Bom uso de Zustand
const useStore = create(set => ({
  user: null,
  posts: [],
  notifications: [],
  setUser: user => set({ user }),
  addPost: post =>
    set(state => ({
      posts: [...state.posts, post],
    })),
  addNotification: notif =>
    set(state => ({
      notifications: [...state.notifications, notif],
    })),
}));

// UserProfile sÃ³ re-renderiza se 'user' muda
const user = useStore(state => state.user);

// PostList sÃ³ re-renderiza se 'posts' muda
const posts = useStore(state => state.posts);
```

---

## ğŸ’¡ O PadrÃ£o: Combinar Ambos

A estratÃ©gia mais inteligente Ã© **usar os dois juntos**:

```typescript
// Zustand para estado complexo e frequente
const useStore = create(set => ({
  user: null,
  posts: [],
  setUser: (user) => set({ user }),
  setPosts: (posts) => set({ posts }),
}));

// Context para valores que mudam raramente
const ThemeContext = createContext();

function App() {
  return (
    <ThemeContext.Provider value={{ theme: 'light' }}>
      {/* Zustand gerencia user e posts */}
      {/* Context gerencia theme */}
    </ThemeContext.Provider>
  );
}
```

**Por quÃª?**

- Zustand cuida do estado que muda frequentemente
- Context cuida de valores globais que raramente mudam
- VocÃª evita re-renders desnecessÃ¡rios
- Melhor separation of concerns

---

## ğŸ” Caso PrÃ¡tico: Dashboard com MÃºltiplos Dados

Imagine um dashboard com:

- **User info** (muda raramente)
- **Posts** (muda com frequÃªncia)
- **Notifications** (muda muito frequentemente)
- **Theme** (muda raramente)

```typescript
// âŒ RUIM: Tudo em Context
const DashboardContext = createContext({
  user: null,
  posts: [],
  notifications: [],
  theme: 'light',
});

// Qualquer mudanÃ§a re-renderiza TUDO

// âœ… BOM: Zustand + Context
const useStore = create(set => ({
  user: null,
  posts: [],
  notifications: [],
  // ...setters
}));

const ThemeContext = createContext();

// UserCard sÃ³ re-renderiza se user muda
const user = useStore(state => state.user);

// PostList sÃ³ re-renderiza se posts muda
const posts = useStore(state => state.posts);

// NotificationBell sÃ³ re-renderiza se notifications muda
const notifications = useStore(state => state.notifications);

// Theme Ã© Context, muda raramente
const theme = useContext(ThemeContext);
```

---

## ğŸš€ Setup RÃ¡pido: Zustand

Se vocÃª decidir usar Zustand, Ã© super simples:

```bash
npm install zustand
```

```typescript
// store.ts
import { create } from 'zustand';

export const useStore = create(set => ({
  user: null,
  setUser: (user) => set({ user }),
}));

// Component.tsx
function MyComponent() {
  const user = useStore(state => state.user);
  return <div>{user?.name}</div>;
}
```

Pronto! Sem providers, sem boilerplate.

---

## ğŸ“ˆ Performance Real

Em um app com 1000 componentes:

**Com Context:**

- MudanÃ§a de `theme` â†’ 50 componentes re-renderizam
- MudanÃ§a de `user` â†’ 50 componentes re-renderizam
- MudanÃ§a de `notifications` â†’ 50 componentes re-renderizam

**Com Zustand:**

- MudanÃ§a de `theme` â†’ 2 componentes re-renderizam
- MudanÃ§a de `user` â†’ 3 componentes re-renderizam
- MudanÃ§a de `notifications` â†’ 5 componentes re-renderizam

A diferenÃ§a Ã© **noite e dia** em apps grandes.

---

## ğŸ“ ConclusÃ£o

| Escolha     | Quando                                                                   |
| ----------- | ------------------------------------------------------------------------ |
| **Context** | App pequena, estado simples, zero dependÃªncias                           |
| **Zustand** | App mÃ©dia/grande, estado complexo, performance Ã© importante              |
| **Ambos**   | Melhor opÃ§Ã£o para apps profissionais (Zustand + Context para temas/i18n) |

**A resposta correta nÃ£o Ã© "use Context"**, Ã© **"use a ferramenta certa para o trabalho"**.

Se vocÃª estÃ¡ construindo uma app profissional, considere seriamente Zustand. A curva de aprendizado Ã© mÃ­nima e os benefÃ­cios sÃ£o significativos.

---

## ğŸ”— Recursos

- [Zustand Documentation](https://github.com/pmndrs/zustand)
- [React Context Documentation](https://react.dev/reference/react/useContext)
- [Redux DevTools Extension](https://github.com/reduxjs/redux-devtools-extension)

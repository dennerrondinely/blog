---
title: 'React 19: A Revolu√ß√£o Async - use(), Action Hooks e muito mais'
description: 'Guia completo das novas features do React 19: use() hook, Action Hooks, <Activity>, useEffectEvent. Entenda como acelerar seu c√≥digo e simplificar estado.'
date: '2026-02-14'
tags: ['react', 'javascript', 'async', 'hooks', 'performance']
locale: 'pt'
---

# ‚ö° React 19: A Revolu√ß√£o Async - use(), Action Hooks e muito mais

React 19 chegou com mudan√ßas significativas que transformam como lidamos com dados ass√≠ncronos, gerenciamento de estado e efeitos colaterais. N√£o s√£o apenas melhorias menores - √© uma revolu√ß√£o.

Neste artigo vou gui√°-lo pelas 4 principais features que todo React developer precisa conhecer.

---

## 1. O Hook `use()` - Promises Diretamente no Render

### O Problema Anterior

Antes, se voc√™ tinha uma promise que precisava ser resolvida antes de renderizar, voc√™ usava `useEffect` + estado:

```typescript
function UserProfile({ dataPromise }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    dataPromise.then(data => {
      setUser(data);
      setLoading(false);
    });
  }, [dataPromise]);

  if (loading) return <div>Loading...</div>;
  return <h1>{user.name}</h1>;
}
```

**Boilerplate, estado desnecess√°rio, e renderiza√ß√µes extras.**

### A Solu√ß√£o: `use()`

O novo hook `use()` resolve promises **diretamente no render**. React automaticamente suspende o componente at√© que os dados estejam prontos:

```typescript
function UserProfile({ dataPromise }) {
  const user = use(dataPromise);
  return <h1>{user.name}</h1>;
}
```

**√â isso.** Uma linha. Sem estados, sem `useEffect`, sem boilerplate.

### Como Funciona

```typescript
// Com Suspense para loading
import { Suspense } from 'react';

function App() {
  const dataPromise = fetchUser();

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <UserProfile dataPromise={dataPromise} />
    </Suspense>
  );
}

function UserProfile({ dataPromise }) {
  // React suspende aqui at√© que a promise resolve
  const user = use(dataPromise);

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### use() tamb√©m funciona com Context

```typescript
// Sem precisar de null checks
const theme = use(ThemeContext);

// Context pode ser undefined? use() lida com isso
const config = use(ConfigContext || DefaultConfig);
```

---

## 2. Action Hooks - Automa√ß√£o de Formul√°rios

### O Problema

Formul√°rios em React requerem muito boilerplate:

```typescript
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isPending, setIsPending] = useState(false);
  const [error, setError] = useState(null);

  async function handleSubmit(e) {
    e.preventDefault();
    setIsPending(true);
    setError(null);

    try {
      await login(email, password);
    } catch (err) {
      setError(err.message);
      setIsPending(false);
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
        disabled={isPending}
      />
      <input
        type="password"
        value={password}
        onChange={e => setPassword(e.target.value)}
        disabled={isPending}
      />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Entrando...' : 'Entrar'}
      </button>
      {error && <span>{error}</span>}
    </form>
  );
}
```

**9 linhas de estado para um formul√°rio simples.**

### A Solu√ß√£o: `useActionState`

O novo hook `useActionState` automatiza tudo:

```typescript
function LoginForm() {
  const [state, action, isPending] = useActionState(submitForm, null);

  async function submitForm(previousState, formData) {
    const email = formData.get('email');
    const password = formData.get('password');

    try {
      await login(email, password);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  return (
    <form action={action}>
      <input type="email" name="email" disabled={isPending} />
      <input type="password" name="password" disabled={isPending} />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Entrando...' : 'Entrar'}
      </button>
      {state?.error && <span>{state.error}</span>}
    </form>
  );
}
```

### O que Muda

- ‚úÖ **Sem mais `useState`** para tracking de estado do formul√°rio
- ‚úÖ **`isPending` autom√°tico** - React rastreia automaticamente
- ‚úÖ **FormData nativa** - Sem precisar fazer parsing manual
- ‚úÖ **Otimista UI** - Suporta atualiza√ß√µes otimistas automaticamente
- ‚úÖ **Reset autom√°tico** - Formul√°rio reseta ap√≥s sucesso

### useTransition para A√ß√µes Customizadas

Se voc√™ quer mais controle, use `useTransition`:

```typescript
const [isPending, startTransition] = useTransition();

function handleClick() {
  startTransition(async () => {
    await updateUser(data);
    // A UI atualiza de forma n√£o-bloqueante
  });
}
```

---

## 3. `<Activity>` - Preserve Scroll Sem Re-renderizar

### O Problema

Quando voc√™ toggle a visibilidade de componentes, o scroll √© perdido:

```typescript
function Page({ showDetails }) {
  return (
    <div>
      <div>Content...</div>
      {showDetails && <Details />}
    </div>
  );
}

// Toggle showDetails? Scroll volta para o topo!
```

### A Solu√ß√£o: `<Activity>`

O novo componente `<Activity>` marca √°reas como "hidden" enquanto preserva o estado:

```typescript
function Page({ showDetails }) {
  return (
    <div>
      <div>Content...</div>
      <Activity mode={showDetails ? 'visible' : 'hidden'}>
        <Details />
      </Activity>
    </div>
  );
}

// showDetails muda? Scroll √© preservado!
```

### Como Funciona

- `mode="visible"` - Componente √© renderizado normalmente
- `mode="hidden"` - Componente √© mantido no DOM mas invis√≠vel
- **Scroll √© preservado** entre toggles
- **Estado √© mantido** sem re-renderizar
- **Performance** - Componente hidden n√£o recebe eventos

### Uso Pr√°tico

```typescript
function Sidebar() {
  const [expanded, setExpanded] = useState(true);

  return (
    <>
      <header>
        <button onClick={() => setExpanded(!expanded)}>
          {expanded ? 'Collapse' : 'Expand'}
        </button>
      </header>

      <Activity mode={expanded ? 'visible' : 'hidden'}>
        <nav>
          <ul>
            {items.map(item => (
              <li key={item.id}>{item.name}</li>
            ))}
          </ul>
        </nav>
      </Activity>
    </>
  );
}
```

---

## 4. `useEffectEvent` - Efeitos Sem Re-execu√ß√£o

### O Problema

Com `useEffect`, voc√™ precisa listar todas as depend√™ncias:

```typescript
function SearchResults({ query, onSuccess }) {
  useEffect(() => {
    const timer = setTimeout(() => {
      search(query).then(results => {
        onSuccess(results); // ‚ö†Ô∏è onSuccess √© uma depend√™ncia
      });
    }, 500);

    return () => clearTimeout(timer);
  }, [query, onSuccess]); // ‚ö†Ô∏è Se onSuccess muda, efeito re-executa

  // Problema: onSuccess muda a cada render, ent√£o efeito rodaria a cada render!
}
```

### A Solu√ß√£o: `useEffectEvent`

Extrai l√≥gica n√£o-reativa do efeito:

```typescript
function SearchResults({ query, onSuccess }) {
  const handleSuccess = useEffectEvent(results => {
    onSuccess(results);
  });

  useEffect(() => {
    const timer = setTimeout(() => {
      search(query).then(results => {
        handleSuccess(results); // ‚úÖ Sem ser depend√™ncia
      });
    }, 500);

    return () => clearTimeout(timer);
  }, [query]); // ‚úÖ Apenas query √© depend√™ncia
}
```

### Quando Usar

**Use `useEffectEvent` para:**

- ‚úÖ Callbacks que voc√™ quer chamar **sem re-executar** o efeito
- ‚úÖ L√≥gica que depende do estado mas **n√£o deve re-executar** o efeito
- ‚úÖ Manter `dependencies` array limpo e focado

**N√£o use para:**

- ‚ùå L√≥gica s√≠ncrona no render (use fun√ß√µes normais)
- ‚ùå Valores que precisam ser reativas (deixe em `dependencies`)

### Exemplo Real: Analytics

```typescript
function Component({ userId, tracking }) {
  const logEvent = useEffectEvent((eventName, data) => {
    tracking.log(eventName, {
      userId,
      timestamp: Date.now(),
      ...data,
    });
  });

  useEffect(() => {
    logEvent('component_mounted');

    return () => logEvent('component_unmounted');
  }, []); // tracking n√£o √© depend√™ncia!
}
```

---

## üöÄ Migration Path: 3 Passos

React 19 foi pensada para coexistir com c√≥digo antigo. Aqui est√° como migrar:

### STEP 1: Refatore Formul√°rios Complexos Primeiro

Comece com `useActionState` em formul√°rios. √â a mudan√ßa mais impactante:

```typescript
// ‚ùå Antes
const [state, setState] = useState(null);
const [isPending, setIsPending] = useState(false);

// ‚úÖ Depois
const [state, action, isPending] = useActionState(handleSubmit, null);
```

### STEP 2: Adote Suspense Boundaries

Mude para Suspense + `use()` para carregamento de dados:

```typescript
// ‚ùå Antes
const [data, setData] = useState(null);
useEffect(() => {
  /* fetch */
}, []);

// ‚úÖ Depois
const data = use(dataPromise);
```

Envolva com `<Suspense>` para fallback loading.

### STEP 3: Mantenha C√≥digo Antigo Funcionando

Novas features funcionam alongside c√≥digo antigo. N√£o precisa reescrever tudo no dia 1.

---

## üìä Compara√ß√£o: React 18 vs React 19

| Feature           | React 18              | React 19             |
| ----------------- | --------------------- | -------------------- |
| Dados Ass√≠ncronos | useEffect + useState  | use() + Suspense     |
| Formul√°rios       | Muito boilerplate     | useActionState       |
| Preserve State    | Dif√≠cil               | Activity simples     |
| Efeito + Callback | Depend√™ncias confusas | useEffectEvent       |
| Bundle Size       | Baseline              | +~10KB (vale a pena) |

---

## ‚ö†Ô∏è Importante: Suspense Boundaries

React 19 torna Suspense mais importante. Sempre envolva com fallbacks:

```typescript
// ‚úÖ BOM
<Suspense fallback={<Loading />}>
  <UserProfile dataPromise={promise} />
</Suspense>

// ‚ùå RUIM - Sem Suspense boundary
<UserProfile dataPromise={promise} /> // Erro se n√£o houver fallback
```

---

## üí° Real-World Example: Complete Form

```typescript
'use client'; // Next.js App Router

import { useActionState, useTransition } from 'react';
import { Suspense } from 'react';

function CreatePostForm({ onSuccess }) {
  const [state, formAction, isPending] = useActionState(
    submitPost,
    null
  );

  async function submitPost(previousState, formData) {
    const title = formData.get('title');
    const content = formData.get('content');

    if (!title || !content) {
      return { error: 'Title and content are required' };
    }

    try {
      const post = await createPost({ title, content });
      onSuccess(post);
      return { success: true, post };
    } catch (error) {
      return { error: error.message };
    }
  }

  return (
    <form action={formAction}>
      <input
        type="text"
        name="title"
        placeholder="Post title"
        required
        disabled={isPending}
      />

      <textarea
        name="content"
        placeholder="Post content"
        required
        disabled={isPending}
      />

      <button type="submit" disabled={isPending}>
        {isPending ? 'Publishing...' : 'Publish'}
      </button>

      {state?.error && (
        <div className="error">{state.error}</div>
      )}

      {state?.success && (
        <div className="success">Post published!</div>
      )}
    </form>
  );
}

// Uso com Suspense
export default function Page() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <CreatePostForm onSuccess={handleSuccess} />
    </Suspense>
  );
}
```

---

## üéì Conclus√£o

React 19 n√£o √© apenas uma atualiza√ß√£o - √© uma mudan√ßa de paradigma:

1. **`use()`** - Async data sem boilerplate
2. **Action Hooks** - Formul√°rios simplificados em 80%
3. **`<Activity>`** - State preservation autom√°tico
4. **`useEffectEvent`** - Efeitos mais previs√≠veis

A curva de aprendizado √© pequena, mas o impacto √© enorme. Se voc√™ est√° em React 18, considere atualizar quando estiver confort√°vel.

**A era de "useEffect + useState" para tudo est√° acabando.**

Bem-vindo a React 19. ‚ö°

---

## üîó Recursos

- [React 19 Documentation](https://react.dev)
- [use() Hook RFC](https://github.com/facebook/react/pull/25360)
- [Actions RFC](https://github.com/facebook/react/issues/26739)
- [Suspense Documentation](https://react.dev/reference/react/Suspense)

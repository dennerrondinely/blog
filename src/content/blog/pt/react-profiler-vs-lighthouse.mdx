---
title: 'React Profiler vs Lighthouse: Ferramentas de Performance que Todo Dev Precisa Conhecer'
description: 'Aprenda a diferenÃ§a entre React Profiler (anÃ¡lise interna de componentes) e Lighthouse (auditoria web completa). Quando usar cada uma e como otimizar seu app.'
date: '2026-02-14'
tags: ['react', 'performance', 'tools', 'debugging', 'lighthouse']
locale: 'pt'
---

# ğŸ” React Profiler vs Lighthouse: Ferramentas de Performance que Todo Dev Precisa Conhecer

Performance Ã© crÃ­tica para qualquer aplicaÃ§Ã£o web. Mas quando vocÃª percebe que sua app estÃ¡ lenta, qual ferramenta vocÃª usa para descobrir o problema?

Neste artigo vamos comparar duas das ferramentas mais poderosas para diagnÃ³stico de performance: **React Profiler** e **Lighthouse**. Vamos entender quando usar cada uma e como trabalhar com elas juntas.

---

## ğŸ§ª React Profiler: AnÃ¡lise Interna de Componentes

O React Profiler Ã© uma ferramenta **interna do React** que mede o desempenho de seus componentes em tempo real.

### O que ele faz

O React Profiler rastreia:

- â±ï¸ **Tempo de renderizaÃ§Ã£o** - Quanto tempo cada componente leva para renderizar
- ğŸ”„ **Re-renders** - Quantas vezes cada componente foi renderizado
- ğŸ“¦ **Size do componente** - Tamanho relativo na Ã¡rvore de componentes
- ğŸ¯ **Commits** - Cada atualizaÃ§Ã£o do DOM e quando ocorreu
- ğŸ”— **RelaÃ§Ã£o entre componentes** - Como os re-renders cascateiam

### Como Usar

O React Profiler estÃ¡ disponÃ­vel nas **React Developer Tools** (extensÃ£o do Chrome):

1. Instale [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
2. Abra a aba **Profiler**
3. Clique em **Record** (botÃ£o redondo)
4. Interaja com sua app (clique em botÃµes, mude estado, etc.)
5. Clique em **Record** novamente para parar
6. Analise os dados coletados

### Exemplo Real: Identificando Renders DesnecessÃ¡rios

```typescript
// âŒ Component que re-renderiza desnecessariamente
function UserList({ users, onSelect }) {
  console.log('UserList renderizado');

  return (
    <div>
      {users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onSelect={onSelect}
        />
      ))}
    </div>
  );
}

function UserCard({ user, onSelect }) {
  console.log(`UserCard renderizado: ${user.id}`);

  return (
    <div onClick={() => onSelect(user.id)}>
      {user.name}
    </div>
  );
}
```

Com o React Profiler vocÃª vai ver:

1. **UserList renderiza sempre** que o estado muda
2. **Todos os UserCard renderizam** mesmo que o usuÃ¡rio especÃ­fico nÃ£o mudou
3. **Tempo total** aumenta exponencialmente com a quantidade de usuÃ¡rios

### SoluÃ§Ã£o com memo()

```typescript
// âœ… Optimizado com React.memo
const UserCard = React.memo(function UserCard({ user, onSelect }) {
  console.log(`UserCard renderizado: ${user.id}`);

  return (
    <div onClick={() => onSelect(user.id)}>
      {user.name}
    </div>
  );
});

function UserList({ users, onSelect }) {
  // memoize callback para evitar que UserCard re-renderize
  const handleSelect = useCallback((userId) => {
    onSelect(userId);
  }, [onSelect]);

  return (
    <div>
      {users.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onSelect={handleSelect}
        />
      ))}
    </div>
  );
}
```

Agora com o React Profiler vocÃª vai ver:

1. âœ… **UserList renderiza normalmente**
2. âœ… **Apenas UserCard que mudou renderiza**
3. âœ… **Tempo total drasticamente reduzido**

---

## ğŸ›ï¸ Lighthouse: Auditoria Web Completa

Lighthouse Ã© uma ferramenta do **Google Chrome** que faz uma auditoria completa da sua aplicaÃ§Ã£o web.

### O que ele faz

Lighthouse mede:

- âš¡ **Performance** - Velocidade geral da pÃ¡gina
- â™¿ **Accessibility** - Acessibilidade para usuÃ¡rios com deficiÃªncia
- ğŸ“± **Best Practices** - Conformidade com prÃ¡ticas recomendadas
- ğŸ”’ **Security** - Vulnerabilidades de seguranÃ§a
- ğŸ“Š **SEO** - OtimizaÃ§Ã£o para mecanismos de busca

### Como Usar

1. Abra o Chrome DevTools (F12 ou Cmd+Option+I)
2. VÃ¡ para a aba **Lighthouse**
3. Selecione o que quer auditar (pode ser Mobile ou Desktop)
4. Clique em **Analyze page load**
5. Aguarde o relatÃ³rio completo

### MÃ©tricas Principais

#### Core Web Vitals

Lighthouse se foca em trÃªs mÃ©tricas crÃ­ticas:

- **LCP** (Largest Contentful Paint)
  - Quando o maior elemento visÃ­vel aparece
  - Alvo: `< 2.5s`

- **FID** (First Input Delay)
  - Quanto tempo a pÃ¡gina leva para responder ao usuÃ¡rio
  - Alvo: `< 100ms`

- **CLS** (Cumulative Layout Shift)
  - Quanto o layout se move enquanto a pÃ¡gina carrega
  - Alvo: `< 0.1`

### Exemplo de RelatÃ³rio

Um relatÃ³rio tÃ­pico do Lighthouse mostra:

```
Performance: 85/100
  âœ“ Largest Contentful Paint: 1.8s
  âœ“ First Input Delay: 45ms
  âœ“ Cumulative Layout Shift: 0.05
  âœ— Unused JavaScript: 245kb
  âœ— Unused CSS: 89kb
  âš  Images not sized correctly: 3 warnings
```

---

## ğŸ¯ ComparaÃ§Ã£o: React Profiler vs Lighthouse

| Aspecto | React Profiler | Lighthouse |
|---------|-------|-----------|
| **Foco** | Componentes React | PÃ¡gina inteira |
| **Causa** | Por que renderiza? | Como otimizar? |
| **MÃ©trica** | Tempo de render | Core Web Vitals |
| **Acesso** | Dentro do app (DevTools) | Em tempo de auditoria |
| **Granularidade** | Componente individual | PÃ¡gina completa |
| **Casos de Uso** | Renders desnecessÃ¡rios | Performance geral |
| **Interatividade** | Analisa interaÃ§Ãµes | Simula carregamento |
| **RelatÃ³rio** | Visual em tempo real | Scorecard detalhado |

---

## ğŸ”„ Workflow PrÃ¡tico: Otimizando com Ambas

### PASSO 1: Comece com Lighthouse

FaÃ§a uma auditoria geral:

```bash
# Via CLI (mais consistente)
npm install -g @lhci/cli@latest lighthouse
lighthouse https://seu-site.com --view
```

**Procure por:**
- Performance score baixo
- Core Web Vitals ruins
- Arquivos nÃ£o usados
- Imagens grandes

### PASSO 2: Use React Profiler para Investigar

Se o Lighthouse apontou "Unused JavaScript" ou "Slow rendering":

1. Abra React Profiler
2. Grave uma interaÃ§Ã£o comum (scroll, clique em botÃ£o)
3. Procure por:
   - Renders que demoram muito
   - Re-renders em cascata
   - Componentes que renderizam sem razÃ£o

### PASSO 3: Implemente OtimizaÃ§Ãµes

Com base no que encontrou:

```typescript
// âŒ Problema: FunÃ§Ã£o definida a cada render
function ProductCard({ product, onAddCart }) {
  const handleClick = () => {
    onAddCart(product.id);
  };

  return (
    <button onClick={handleClick}>
      Adicionar ao carrinho
    </button>
  );
}

// âœ… SoluÃ§Ã£o: Memoize a funÃ§Ã£o
function ProductCard({ product, onAddCart }) {
  const handleClick = useCallback(() => {
    onAddCart(product.id);
  }, [product.id, onAddCart]);

  return (
    <button onClick={handleClick}>
      Adicionar ao carrinho
    </button>
  );
}

// âœ… SoluÃ§Ã£o 2: Memoize o componente inteiro
export const MemoizedProductCard = React.memo(ProductCard);
```

### PASSO 4: Valide com Lighthouse Novamente

Rode o Lighthouse de novo para confirmar as melhorias:

```bash
lighthouse https://seu-site.com --view
```

**VocÃª deve ver:**
- Score de Performance aumentar
- Core Web Vitals melhorar
- "Unused JavaScript" diminuir

---

## ğŸ“Š MÃ©tricas PrÃ¡ticas do React Profiler

### Entender o GrÃ¡fico

Quando vocÃª grava uma interaÃ§Ã£o, o Profiler mostra:

```
Commit 1: 234ms
  â”œâ”€ UserList: 45ms (renderizado)
  â”œâ”€ UserCard: 12ms (renderizado)
  â”œâ”€ UserCard: 11ms (renderizado)
  â””â”€ UserCard: 10ms (renderizado)

Commit 2: 89ms
  â”œâ”€ UserList: 0ms (nÃ£o renderizado)
  â”œâ”€ UserCard: 2ms (renderizado - mudou!)
  â”œâ”€ UserCard: 0ms (nÃ£o renderizado)
  â””â”€ UserCard: 0ms (nÃ£o renderizado)
```

**Cores no Profiler:**
- ğŸŸ© **Verde claro** - RenderizaÃ§Ã£o rÃ¡pida (`< 5ms`)
- ğŸŸ¨ **Amarelo** - RenderizaÃ§Ã£o mÃ©dia (`5-20ms`)
- ğŸŸ¥ **Vermelho** - RenderizaÃ§Ã£o lenta (`> 20ms`)

---

## ğŸš€ Checklist de OtimizaÃ§Ã£o

ApÃ³s encontrar problemas com essas ferramentas:

### React Profiler (OtimizaÃ§Ãµes Internas)

- [ ] Use `React.memo()` para componentes que recebem muitas props
- [ ] Use `useCallback()` para funÃ§Ãµes passadas como props
- [ ] Use `useMemo()` para objetos/arrays caros de calcular
- [ ] Considere state colocation (mova estado para perto de onde Ã© usado)
- [ ] Divida componentes grandes em componentes menores

### Lighthouse (OtimizaÃ§Ãµes Gerais)

- [ ] Minimize JavaScript nÃ£o utilizado
- [ ] Otimize imagens (use WebP, lazy load)
- [ ] Implemente code splitting
- [ ] Use CDN para assets estÃ¡ticos
- [ ] Implemente service workers para cache
- [ ] Melhore Core Web Vitals

---

## ğŸ’¡ Casos Reais

### Caso 1: E-commerce Lento

**Descoberto com Lighthouse:**
- Performance score: 42/100
- LCP lento (4.2s)

**Investigado com React Profiler:**
- ProductCard renderiza 500 vezes mesmo com dados iguais
- useCallback faltando no filtro

**SoluÃ§Ã£o:**
```typescript
// Adicionar useCallback ao filtro
const handleFilter = useCallback((category) => {
  setFilteredProducts(
    products.filter(p => p.category === category)
  );
}, [products]);
```

**Resultado:** Performance score: 87/100, LCP: 1.8s

---

### Caso 2: Dashboard com Muitos GrÃ¡ficos

**Descoberto com Lighthouse:**
- Performance score: 55/100
- Unused JavaScript: 620kb

**Investigado com React Profiler:**
- Cada grÃ¡fico renderiza mesmo que dados nÃ£o mudaram
- Todas as bibliotecas de grÃ¡ficos carregadas mesmo com apenas 2 em uso

**SoluÃ§Ã£o:**
```typescript
// Code splitting das bibliotecas
const LineChart = lazy(() => import('./charts/LineChart'));
const BarChart = lazy(() => import('./charts/BarChart'));

// Memoize grÃ¡ficos
const MemoChart = React.memo(Chart);
```

**Resultado:** Performance score: 91/100, Unused JS: 120kb

---

## ğŸ“ ConclusÃ£o

**Use React Profiler quando:**
- âœ… VocÃª quer entender **por quÃª** o componente renderiza
- âœ… Investigar renders em cascata
- âœ… Otimizar re-renders desnecessÃ¡rios
- âœ… Debugar problemas especÃ­ficos de React

**Use Lighthouse quando:**
- âœ… Fazer auditoria geral de performance
- âœ… Medir Core Web Vitals
- âœ… Verificar acessibilidade e SEO
- âœ… Validar melhorias implementadas

**A abordagem ideal:**

1. Comece com **Lighthouse** para identificar o problema geral
2. Use **React Profiler** para investigar causas especÃ­ficas
3. Implemente otimizaÃ§Ãµes
4. Valide com **Lighthouse** novamente

Juntas, essas ferramentas formam uma dupla poderosa para dominar a performance de sua aplicaÃ§Ã£o React.

---

## ğŸ”— Recursos

- [React DevTools](https://chrome.google.com/webstore/detail/react-developer-tools)
- [Lighthouse Documentation](https://developers.google.com/web/tools/lighthouse)
- [Core Web Vitals Guide](https://web.dev/vitals/)
- [React Profiler API](https://react.dev/reference/react/Profiler)
- [Web.dev Performance Course](https://web.dev/performance/)

---

_Qual ferramenta vocÃª mais usa? React Profiler ou Lighthouse? Deixa nos comentÃ¡rios!_ ğŸ‘‡
